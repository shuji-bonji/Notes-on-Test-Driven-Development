import{_ as a,c as e,o as n,ag as s}from"./chunks/framework.BdLwk_4I.js";const c=JSON.parse('{"title":"Web Components に TDD の適用は難しい","description":"","frontmatter":{},"headers":[],"relativePath":"docs/applying-TDD-to-WebComponents-is-difficult.md","filePath":"docs/applying-TDD-to-WebComponents-is-difficult.md"}'),d={name:"docs/applying-TDD-to-WebComponents-is-difficult.md"};function o(r,t,i,p,l,h){return n(),e("div",null,t[0]||(t[0]=[s(`<h1 id="web-components-に-tdd-の適用は難しい" tabindex="-1">Web Components に TDD の適用は難しい <a class="header-anchor" href="#web-components-に-tdd-の適用は難しい" aria-label="Permalink to &quot;Web Components に TDD の適用は難しい&quot;">​</a></h1><p>Web Components は再利用性の高い UI コンポーネントを作るうえで非常に有用ですが、その内部構造や振る舞いが特殊であるため、TDD を直接適用しようとするといくつかの困難に直面します。<br> このドキュメントでは、その理由と、現実的かつ効果的なアプローチについて解説します。</p><p>Web Componentsを使う場合、TDDを「UIコンポーネント」そのものに厳密に適用しようとすると難易度が高くなるため、TDDは「アプリケーションのロジック層（ドメイン／ビジネスルール）」に対して適用するのが現実的かつ効果的です。</p><p>Web ComponentsとTDDを無理に結びつけず、「UIとロジックの責務分離」をして、ロジック側にTDDを適用するのが現実的で効果的です。 UI層は「接続部分を検証する程度」にとどめ、ロジックの堅牢性をTDDで担保するのがベストプラクティスです。</p><h2 id="web-components-×-tdd-が難しい理由" tabindex="-1">Web Components × TDD が難しい理由 <a class="header-anchor" href="#web-components-×-tdd-が難しい理由" aria-label="Permalink to &quot;Web Components × TDD が難しい理由&quot;">​</a></h2><p>なぜ Web Components に TDD をそのまま適用するのが難しいのか、具体的な技術的観点から見ていきましょう。</p><table tabindex="0"><thead><tr><th>理由</th><th>詳細</th></tr></thead><tbody><tr><td>DOM操作と密接で状態が外部依存</td><td>属性・イベント・スロットなど、外部のHTMLやDOMとの相互作用が多い</td></tr><tr><td>状態の変化が非同期</td><td>属性変更・イベントディスパッチ・描画の完了タイミングなどが async</td></tr><tr><td>テストに Shadow DOM 対応が必要</td><td>shadowRoot の中身まで確認しないと動作保証できない</td></tr><tr><td>初期化やライフサイクルが特殊</td><td>connectedCallback, attributeChangedCallback などを正確にテストするには環境が必要</td></tr></tbody></table><h2 id="よって、tddに向いているのは「ドメインロジック層」" tabindex="-1">よって、TDDに向いているのは「ドメインロジック層」 <a class="header-anchor" href="#よって、tddに向いているのは「ドメインロジック層」" aria-label="Permalink to &quot;よって、TDDに向いているのは「ドメインロジック層」&quot;">​</a></h2><p>上記のような制約を踏まえると、TDD の効果を最大限に引き出すには、UI ではなくロジック層に注目するのが現実的です。</p><h3 id="例-アプリケーション構造の分離" tabindex="-1">例：アプリケーション構造の分離 <a class="header-anchor" href="#例-アプリケーション構造の分離" aria-label="Permalink to &quot;例：アプリケーション構造の分離&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>📁 /src</span></span>
<span class="line"><span>  ├── /components</span></span>
<span class="line"><span>  │     └── my-user-form.ts       ← Web Component（TDD困難な部分）</span></span>
<span class="line"><span>  ├── /domain</span></span>
<span class="line"><span>  │     └── user.ts               ← TDD対象（Userのバリデーション、登録条件など）</span></span>
<span class="line"><span>  ├── /services</span></span>
<span class="line"><span>  │     └── user-service.ts       ← TDD対象（登録処理、DB保存など）</span></span>
<span class="line"><span>  └── /utils</span></span>
<span class="line"><span>        └── email-validator.ts    ← TDD対象（関数単位）</span></span></code></pre></div><h3 id="tdd対象例" tabindex="-1">TDD対象例： <a class="header-anchor" href="#tdd対象例" aria-label="Permalink to &quot;TDD対象例：&quot;">​</a></h3><table tabindex="0"><thead><tr><th>層</th><th>テスト対象例</th></tr></thead><tbody><tr><td>domain/user.ts</td><td>User の生成条件、isValid() のようなドメインロジック</td></tr><tr><td>services/user-service.ts</td><td>登録・重複チェック・通知など、ビジネスルール</td></tr><tr><td>utils/email-validator.ts</td><td>単一関数としてのユニットテスト</td></tr></tbody></table><h2 id="ui層-web-components-は「テスト後」-「最小限の振る舞いテスト」でok" tabindex="-1">UI層（Web Components）は「テスト後」＋「最小限の振る舞いテスト」でOK <a class="header-anchor" href="#ui層-web-components-は「テスト後」-「最小限の振る舞いテスト」でok" aria-label="Permalink to &quot;UI層（Web Components）は「テスト後」＋「最小限の振る舞いテスト」でOK&quot;">​</a></h2><p>UI 層もまったくテストしないわけではありませんが、TDD のような厳密なループで行うには適していません。<br> ここでは、UI に対する適切なテストアプローチについて説明します。</p><table tabindex="0"><thead><tr><th>テストスタイル</th><th>用途</th></tr></thead><tbody><tr><td>単体ユニットテスト</td><td>属性・イベントの受け渡しなどシンプルな振る舞い確認</td></tr><tr><td>E2Eテスト（Playwrightなど）</td><td>ユーザー操作を通じた総合動作確認</td></tr><tr><td>Storybook + Jest</td><td>UI状態のスナップショットテスト（非推奨だが一部で使われる）</td></tr></tbody></table><h2 id="責務を明確に分離する" tabindex="-1">責務を明確に分離する <a class="header-anchor" href="#責務を明確に分離する" aria-label="Permalink to &quot;責務を明確に分離する&quot;">​</a></h2><p>そのためには、アプリケーション内の各層における責務の分離が不可欠です。<br> 以下のように、ロジック・状態管理・UI を分けて考えると、それぞれに最適なテスト戦略が見えてきます。</p><table tabindex="0"><thead><tr><th>対象層</th><th>テスト戦略</th></tr></thead><tbody><tr><td>ビジネスロジック層</td><td>純粋なJavaScriptで実装し、TDDで徹底的にテスト</td></tr><tr><td>状態管理層</td><td>データの流れと状態変化をTDDでテスト</td></tr><tr><td>プレゼンテーション層</td><td>WebComponentsの見た目や振る舞いは、必要に応じて統合テストやビジュアルテストで補完</td></tr></tbody></table><h2 id="実際の開発フロー" tabindex="-1">実際の開発フロー <a class="header-anchor" href="#実際の開発フロー" aria-label="Permalink to &quot;実際の開発フロー&quot;">​</a></h2><p>では、実際にどのような順序で開発・テストを進めるのが効果的なのでしょうか。<br> TDD を活かした現実的なフローの一例を紹介します。</p><ol><li>ロジックやルールを TDD で先に設計・実装</li><li>その後 Web Component の UI に「ロジック層を注入」</li><li>UI 層では「最低限の振る舞い」だけをテスト（属性変化やイベント発火）</li></ol>`,22)]))}const D=a(d,[["render",o]]);export{c as __pageData,D as default};
